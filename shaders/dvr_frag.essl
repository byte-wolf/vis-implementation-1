#ifndef GL_ES
#version 330 es
#endif

precision highp int;
precision highp float;
precision highp sampler3D;

in vec3 vWorldPosition;

// --- Camera Uniforms ---
uniform vec3 uCameraPosition;

// --- Volume Texture Uniforms ---
uniform sampler3D uVolumeTexture;
uniform vec3 uVolumeSize;

// --- Static background and foreground color uniforms ---
uniform vec3 uBackgroundColor;
uniform vec3 uForegroundColor;

// --- Cutting Plane Uniforms ---
uniform int uCuttingPlaneEnabled;
uniform vec3 uCuttingPlanePosition;
uniform vec3 uCuttingPlaneRotation;

// --- Transfer Function / Isosurface Uniforms ---
const int MAX_ISO_POINTS = 4;
uniform int uNumIsoPoints;
uniform float uIsoValues[MAX_ISO_POINTS];
uniform float uIsoOpacities[MAX_ISO_POINTS];
uniform vec3 uIsoColors[MAX_ISO_POINTS];
uniform float uIsoRange;

// --- Render Mode Uniform ---
// 0: Maximum Intensity Projection
// 1: Transfer Function
// 2: Transfer Function (Old)
uniform int uRenderMode;

out vec4 fragColor;

// https://tavianator.com/2011/ray_box.html
bool intersectBox(vec3 rayOrigin, vec3 rayDirection, out float tMin, out float tMax) {
    vec3 boxMin = -uVolumeSize * 0.5;
    vec3 boxMax = uVolumeSize * 0.5;

    vec3 invDir = 1.0 / rayDirection;

    vec3 tMinPlane = (boxMin - rayOrigin) * invDir;
    vec3 tMaxPlane = (boxMax - rayOrigin) * invDir;

    vec3 t1 = min(tMinPlane, tMaxPlane);
    vec3 t2 = max(tMinPlane, tMaxPlane);

    tMin = max(max(t1.x, t1.y), t1.z);
    tMax = min(min(t2.x, t2.y), t2.z);

    return tMin < tMax && tMax > 0.0;
}

vec4 applyTransferFunction(float density) {
    vec4 sampleProperties = vec4(0.0);

    for(int idx = 0; idx < uNumIsoPoints; ++idx) {
        if(idx >= MAX_ISO_POINTS) {
            break;
        }

        float isoVal = uIsoValues[idx];
        float pointOpacity = uIsoOpacities[idx];
        vec3 pointColor = uIsoColors[idx];

        // Calculate how close the density is to the current iso-value
        float dist = abs(density - isoVal);
        float intensity = 0.0;

        if(dist < uIsoRange) {
            intensity = 1.0 - (dist / uIsoRange); // Linear falloff
        }

        if(intensity > 0.0) {
            float currentRuleAlpha = pointOpacity * intensity;
            sampleProperties.rgb += (1.0 - sampleProperties.a) * currentRuleAlpha * pointColor;
            sampleProperties.a += (1.0 - sampleProperties.a) * currentRuleAlpha;

            if(sampleProperties.a >= 0.99) {
                break;
            }
        }
    }
    return sampleProperties;
}

// Simple pseudo-random function for jittering
float random(vec2 co) {
    // Multiply by a large number and take the fractional part
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void maximumIntensityProjectionRender(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax, float dt) {
    float maxIntensity = 0.0;

    for(float t = tMin; t < tMax; t += dt) {
        vec3 currentPos = rayOrigin + rayDirection * t;

        // Apply cutting plane only if enabled
        if(uCuttingPlaneEnabled == 1) {
            float d = dot(currentPos - uCuttingPlanePosition, uCuttingPlaneRotation);

            if(d < 0.0) {
                continue; // Skip points behind the plane
            }
        }

        vec3 textureCoord = (currentPos / uVolumeSize) + 0.5;

        if(all(greaterThanEqual(textureCoord, vec3(0.0))) && all(lessThanEqual(textureCoord, vec3(1.0)))) {
            float density = texture(uVolumeTexture, textureCoord).r;
            maxIntensity = max(maxIntensity, density);
        }
    }

    if(maxIntensity <= 0.01) {
        discard;
    }

    fragColor = vec4(mix(uBackgroundColor, uForegroundColor, maxIntensity), 1.0);
}

// https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-39-volume-rendering-techniques
void transferFunctionRender(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax, float dt) {
    vec4 accumulatedColor = vec4(0.0, 0.0, 0.0, 0.0);
    float stepRatio = 0.5;

    for(float t = tMin; t < tMax; t += dt) {
        vec3 currentPos = rayOrigin + rayDirection * t;

        // Apply cutting plane
        if(uCuttingPlaneEnabled == 1) {
            float d = dot(currentPos - uCuttingPlanePosition, uCuttingPlaneRotation);

            if(d < 0.0) {
                continue; // Skip points behind the plane
            }
        }

        vec3 textureCoord = (currentPos / uVolumeSize) + 0.5;

        if(all(greaterThanEqual(textureCoord, vec3(0.0))) && all(lessThanEqual(textureCoord, vec3(1.0)))) {
            float density = texture(uVolumeTexture, textureCoord).r;

            vec4 sampleProperties = applyTransferFunction(density); // Returns {premultiplied_col_A0.rgb, alpha_A0}

            if(sampleProperties.a > 0.0) {
                float alpha_corrected = 1.0 - pow(1.0 - sampleProperties.a, stepRatio);
                accumulatedColor.rgb += (1.0 - accumulatedColor.a) * sampleProperties.rgb * (alpha_corrected / sampleProperties.a);
                accumulatedColor.a += (1.0 - accumulatedColor.a) * alpha_corrected;
            }

            if(accumulatedColor.a >= 1.0) {
                break;
            }
        }
    }

    if(accumulatedColor.a <= 0.01) {
        discard;
    }

    // Composite the volume's color (accumulatedColor.rgb, which is pre-multiplied)
    // over the background color.
    // C_final = C_volume + (1 - Alpha_volume) * C_background
    vec3 finalRgb = accumulatedColor.rgb + (1.0 - accumulatedColor.a) * uBackgroundColor;
    fragColor = accumulatedColor; // Output opaque color after blending with background
}

void transferFunctionRenderOld(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax, float dt) {
    vec4 accumulatedColor = vec4(uBackgroundColor, 0.0);

    for(float t = tMin; t < tMax; t += dt) {
        vec3 currentPos = rayOrigin + rayDirection * t;

        // Apply cutting plane
        if(uCuttingPlaneEnabled == 1) {
            float d = dot(currentPos - uCuttingPlanePosition, uCuttingPlaneRotation);

            if(d < 0.0) {
                continue; // Skip points behind the plane
            }
        }

        vec3 textureCoord = (currentPos / uVolumeSize) + 0.5;

        if(all(greaterThanEqual(textureCoord, vec3(0.0))) && all(lessThanEqual(textureCoord, vec3(1.0)))) {
            float density = texture(uVolumeTexture, textureCoord).r;

            vec4 sampleColor = applyTransferFunction(density);

            // Front-to-back alpha compositing
            if(sampleColor.a > 0.0) {
                accumulatedColor.rgb += (1.0 - accumulatedColor.a) * sampleColor.a * sampleColor.rgb;
                accumulatedColor.a += (1.0 - accumulatedColor.a) * sampleColor.a;
            }

            if(accumulatedColor.a >= 1.0) {
                break;
            }
        }
    }

    if(accumulatedColor.a <= 0.01) {
        discard;
    }

    fragColor = accumulatedColor; // Output opaque color after blending with background
}

void main() {
    vec3 rayOrigin = uCameraPosition;
    vec3 rayDirection = normalize(vWorldPosition - rayOrigin);

    float tMin, tMax;
    bool hit = intersectBox(rayOrigin, rayDirection, tMin, tMax);

    if(!hit) {
        discard;
    }

    tMin = max(tMin, 0.0);

    float dt = 0.5;
    //tMin += random(vWorldPosition.xy) * dt;

    if(uRenderMode == 0) {
        maximumIntensityProjectionRender(rayOrigin, rayDirection, tMin, tMax, dt);
    } else if(uRenderMode == 1) {
        transferFunctionRender(rayOrigin, rayDirection, tMin, tMax, dt);
    } else if(uRenderMode == 2) {
        transferFunctionRenderOld(rayOrigin, rayDirection, tMin, tMax, dt);
    }
}