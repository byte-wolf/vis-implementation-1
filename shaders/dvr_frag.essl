#ifndef GL_ES
#version 330 es
#endif

precision highp int;
precision highp float;
precision highp sampler3D;

// --- Vertex Attributes ---
in vec3 vTransformedPosition;
in vec3 vTransformedCameraPosition;
in vec3 vRayDirection;
in vec3 vCuttingPlanePositionTransformed;

// --- Volume Texture Uniforms ---
uniform vec3 uVolumeSize;
uniform sampler3D uVolumeTexture;

// --- Static background and foreground color uniforms ---
uniform vec3 uBackgroundColor;
uniform vec3 uForegroundColor;

// --- Cutting Plane Uniforms ---
uniform int uCuttingPlaneEnabled;
uniform vec3 uCuttingPlaneRotation;

// --- Transfer Function / Isosurface Uniforms ---
const int MAX_ISO_POINTS = 4;
uniform int uNumIsoPoints;
uniform float uIsoValues[MAX_ISO_POINTS];
uniform float uIsoOpacities[MAX_ISO_POINTS];
uniform vec3 uIsoColors[MAX_ISO_POINTS];
uniform float uIsoRange;
uniform int uIsoFalloffMode; // 0: Linear falloff, 1: Binary

// --- Render Mode Uniform ---
// 0: Maximum Intensity Projection
// 1: Maximum Intensity Projection (TF)
// 2: Accumulative
// 3: Accumulative (Alpha Blending)
uniform int uRenderMode;

out vec4 fragColor;

float calculateSampleDistance(vec3 rayDirection) {
    float epsilon = 0.00001;
    vec3 absoluteScaledRayDirection = (abs(vRayDirection)) * uVolumeSize;
    float minComponent = min(absoluteScaledRayDirection.x, min(absoluteScaledRayDirection.y, absoluteScaledRayDirection.z));

    if(minComponent > epsilon) {
        return 1.0 / minComponent;
    } else {
        return 0.001;
    }
}

// https://tavianator.com/2011/ray_box.html
bool intersectBox(vec3 rayOrigin, vec3 rayDirection, out float tMin, out float tMax) {
    vec3 boxMin = vec3(0.0);
    vec3 boxMax = vec3(1.0);

    vec3 invDir = 1.0 / rayDirection;

    vec3 tMinPlane = (boxMin - rayOrigin) * invDir;
    vec3 tMaxPlane = (boxMax - rayOrigin) * invDir;

    vec3 t1 = min(tMinPlane, tMaxPlane);
    vec3 t2 = max(tMinPlane, tMaxPlane);

    tMin = max(max(t1.x, t1.y), t1.z);
    tMax = min(min(t2.x, t2.y), t2.z);

    return tMin <= tMax && tMax >= 0.0;
}

vec4 applyTransferFunction(float density, int falloffMode) {
    vec4 sampleProperties = vec4(0.0);

    for(int idx = 0; idx < uNumIsoPoints; ++idx) {
        if(idx >= MAX_ISO_POINTS) {
            break;
        }

        float isoVal = uIsoValues[idx];
        float pointOpacity = uIsoOpacities[idx];
        vec3 pointColor = uIsoColors[idx];

        // Calculate how close the density is to the current iso-value
        float dist = abs(density - isoVal);
        float intensity = 0.0;

        if(dist < uIsoRange) {
            if(falloffMode == 0) {
                intensity = 1.0 - (dist / uIsoRange); // Linear falloff
            } else if(falloffMode == 1) {
                intensity = 1.0; // Binary
            }
        }

        if(intensity > 0.0) {
            float currentRuleAlpha = pointOpacity * intensity;
            sampleProperties.rgb += (1.0 - sampleProperties.a) * currentRuleAlpha * pointColor;
            sampleProperties.a += (1.0 - sampleProperties.a) * currentRuleAlpha;

            if(sampleProperties.a >= 1.0) {
                break;
            }
        }
    }
    return sampleProperties;
}

// Simple pseudo-random function for jittering
float random(vec2 co) {
    // Multiply by a large number and take the fractional part
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void maximumIntensityProjectionRender(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax, float dt, bool useTransferFunction) {
    float maxIntensity = 0.0;

    for(float t = tMin; t < tMax; t += dt) {
        vec3 textureCoord = rayOrigin + rayDirection * t;

        // Apply cutting plane only if enabled
        if(uCuttingPlaneEnabled == 1) {
            float d = dot(textureCoord - vCuttingPlanePositionTransformed, uCuttingPlaneRotation);

            if(d < 0.0) {
                continue; // Skip points behind the plane
            }
        }

        if(all(greaterThanEqual(textureCoord, vec3(0.0))) && all(lessThanEqual(textureCoord, vec3(1.0)))) {
            float density = texture(uVolumeTexture, textureCoord).r;
            maxIntensity = max(maxIntensity, density);

            // Early ray termination
            if(maxIntensity >= 1.0) {
                break;
            }
        }
    }

    if(maxIntensity <= 0.1) {
        discard;
    }

    if(useTransferFunction == true) {
        fragColor = applyTransferFunction(maxIntensity, uIsoFalloffMode);
    } else {
        //fragColor = vec4(mix(uBackgroundColor, uForegroundColor, maxIntensity) + vec3(0.2, 0.0, 0.0), 1.0);
        fragColor = vec4(uForegroundColor, maxIntensity);
    }
}

// https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-39-volume-rendering-techniques
void transferFunctionRender(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax, float dt) {
    vec4 accumulatedColor = vec4(0.0, 0.0, 0.0, 0.0);
    float stepRatio = 0.5;

    for(float t = tMin; t < tMax; t += dt) {
        vec3 currentPos = rayOrigin + rayDirection * t;

        // Apply cutting plane
        if(uCuttingPlaneEnabled == 1) {
            float d = dot(currentPos - vCuttingPlanePositionTransformed, uCuttingPlaneRotation);

            if(d < 0.0) {
                continue; // Skip points behind the plane
            }
        }

        vec3 textureCoord = currentPos;

        if(all(greaterThanEqual(textureCoord, vec3(0.0))) && all(lessThanEqual(textureCoord, vec3(1.0)))) {
            float density = texture(uVolumeTexture, textureCoord).r;

            vec4 sampleProperties = applyTransferFunction(density, uIsoFalloffMode); // Returns {premultiplied_col_A0.rgb, alpha_A0}

            if(sampleProperties.a > 0.0) {
                float alpha_corrected = 1.0 - pow(1.0 - sampleProperties.a, stepRatio);
                accumulatedColor.rgb += (1.0 - accumulatedColor.a) * sampleProperties.rgb * (alpha_corrected / sampleProperties.a);
                accumulatedColor.a += (1.0 - accumulatedColor.a) * alpha_corrected;
            }

            // Early ray termination
            if(accumulatedColor.a >= 1.0) {
                break;
            }
        }
    }

    if(accumulatedColor.a <= 0.01) {
        discard;
    }

    fragColor = accumulatedColor;
}

void transferFunctionRenderOld(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax, float dt) {
    vec4 accumulatedColor = vec4(uBackgroundColor, 0.0);

    for(float t = tMin; t < tMax; t += dt) {
        vec3 textureCoord = rayOrigin + rayDirection * t;

        // Apply cutting plane
        if(uCuttingPlaneEnabled == 1) {
            float d = dot(textureCoord - vCuttingPlanePositionTransformed, uCuttingPlaneRotation);

            if(d < 0.0) {
                continue; // Skip points behind the plane
            }
        }

        if(all(greaterThanEqual(textureCoord, vec3(0.0))) && all(lessThanEqual(textureCoord, vec3(1.0)))) {
            float density = texture(uVolumeTexture, textureCoord).r;

            vec4 sampleColor = applyTransferFunction(density, uIsoFalloffMode);

            if(sampleColor.a > 0.0) {
                accumulatedColor.rgb += (1.0 - accumulatedColor.a) * sampleColor.a * sampleColor.rgb;
                accumulatedColor.a += (1.0 - accumulatedColor.a) * sampleColor.a;
            }

            // Early ray termination
            if(accumulatedColor.a >= 1.0) {
                break;
            }
        }
    }

    if(accumulatedColor.a <= 0.01) {
        discard;
    }

    fragColor = accumulatedColor; // Output opaque color after blending with background
}

void main() {
    vec3 normalizedRayDirection = normalize(vRayDirection);

    float tMin, tMax;
    bool hit = intersectBox(vTransformedCameraPosition, normalizedRayDirection, tMin, tMax);

    if(!hit) {
        discard;
    }

    tMin = max(tMin, 0.0);

    float dt = 0.005;
    //float dt = calculateSampleDistance(normalizedRayDirection);
    //tMin += random(vTransformedPosition.xy) * dt / 2.0;

    if(uRenderMode == 0) {
        maximumIntensityProjectionRender(vTransformedCameraPosition, normalizedRayDirection, tMin, tMax, dt, false);
    } else if(uRenderMode == 1) {
        maximumIntensityProjectionRender(vTransformedCameraPosition, normalizedRayDirection, tMin, tMax, dt, true);
    } else if(uRenderMode == 2) {
        transferFunctionRender(vTransformedCameraPosition, normalizedRayDirection, tMin, tMax, dt);
    } else if(uRenderMode == 3) {
        transferFunctionRenderOld(vTransformedCameraPosition, normalizedRayDirection, tMin, tMax, dt);
    }
}